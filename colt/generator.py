from abc import ABC, abstractmethod
from collections import namedtuple
from collections.abc import MutableMapping 
#
import configparser
import re


class GeneratorBase(ABC):
    """Contains all core logic to generate
       code from a given config string/file

       Main use is the QuestionGenerator in colt,
       but it can also be used for other config based
       automatic code generators

       **IMPORTANT NOTE**:
       This works only if the objects generated by this method behave like
       `dictionaries` unless they are `leaf nodes`, which can be anything.
       They need therefore to have get(key, default=None) implemented!

       The tree generated by the basic generator can contain the following
       elements:

                 Node: basic container for the elements of our tree
                       basically is a `dict` and should behave like one
                       every node can contain several subnodes.

            Leaf Node: the actual elements one wants to store within
                       the tree, they are stored at the end

            Branching: a conditional branching. Similar to a standard `Node`,
                       but a branching contains a Leaf Node and then a dict of `Nodes`.

        A tree can be any of the elements above, but typically it is
        either a Branching or a Node
    """

    # please select leaf and branching type
    leafnode_type = None
    branching_type = None
    #
    node_type = dict
    #
    seperator = "::"
    default = '__GENERATOR__'
    # is there a branching in the tree?
    is_branching_regex = re.compile(r"(?P<branch>.*)\((?P<node>.*)\)")
    # named tuple to store the pair
    Branch = namedtuple("Branch", ["branch", "node"])

    def __init__(self, config):
        """Main Object to generate abstract tree from configstring

        Args:
            config(string):
                string that should be converted in the tree
        """
        if not isinstance(config, str):
            raise TypeError("Generator only accepts type string!")
        self.tree = self.configstring_to_tree(config)

    @classmethod
    def configstring_to_tree(cls, string):
        """transform a configstring to a tree object"""
        questions = cls._preprocess_configstring(string)
        return cls.generate_tree(questions)

    @classmethod
    def get_node(cls, tree, node_name):
        """Parse down the abstraction tree to extract
           a particular node based on its block name
        """
        nodes = node_name.split(cls.seperator)
        for node in nodes:
            tree = cls._get_next_node(tree, node)
            if tree is None:
                return
        return tree

    @classmethod
    @abstractmethod
    def new_branching(cls, name, leaf=None):
        """Create a new empty branching"""

    @staticmethod
    def new_node():
        """Create a new node of the tree"""
        return {}

    @classmethod
    @abstractmethod
    def leaf_from_string(cls, name, value):
        """Create a leaf from an entry in the config file

        Args:
            name (str):
                name of the entry

            value (str):
                value of the entry in the config

        Returns:
            A leaf node

        Raises:
            ValueError:
                If the value cannot be parsed
        """

    @staticmethod
    def _preprocess_string(string):
        """Basic Preprocessor"""
        return string

    @classmethod
    def _preprocess_configstring(cls, string):
        """Prepation setup for the parsing of strings into configs"""
        string = cls._preprocess_string(string)
        # add [DEFAULT] for easier parsing!
        if not string.lstrip().startswith(f'[{cls.default}]'):
            string = f'[{cls.default}]\n' + string
        #
        config = configparser.ConfigParser()
        config.read_string(string)
        return config

    @classmethod
    def _is_branching(cls, node):
        """check if node is a branching node"""
        branch = cls.is_branching_regex.match(node)
        if branch is None:
            return False
        return cls.Branch(branch.group("branch"), branch.group("node"))

    @classmethod
    def _get_next_node(cls, tree, node):
        """Get the next node of the current tree
           using the key to the node!

           Args:
                tree (object):
                    Python object that behaves like tree with
                    only dictionaries inside or objects that
                    behave like dictionaries

                node (string):
                    string to determine the next node
        """

        conditions = cls._is_branching(node)
        if conditions is False:
            return tree.get(node, None)

        node, case = conditions
        tree = tree.get(node, None)
        if tree is not None:
            return tree.get(case, None)
        return tree

    @classmethod
    def _get_parent_node(cls, node, tree):
        """Go iterative through the tree and get
           the final node, one over the selected one
           This is done in case the selected node does not
           exist and should be created.

           Args:
                node (str):
                    String to find the corresponding node in the tree

                tree (object):
                    python object that behaves like a dict of dicts
            Returns:
                final_node (str):
                    identifier of the final node
                tree (object):
                    tree object of the parent node
        """
        #
        nodes = node.split(cls.seperator)
        final_node = nodes[-1]
        #
        for node in nodes[:-1]:
            tree = cls._get_next_node(tree, node)
            if tree is None:
                return None, None
        return final_node, tree

    @classmethod
    def _select_subnode(cls, tree, nodeblock):
        """Get a node from the tree creates if it does not exist
           inside the parent node, creates it!
           iterative loop over the nodes till the selected one is reached
           in case the parent node is a branching, create a new one, if
           it is not done yet

        """
        node, tree = cls._get_parent_node(nodeblock, tree)
        if node is None:
            return
        # if is not decission, create the new node as an dict
        conditions = cls._is_branching(node)
        if conditions is False:
            if node in tree:
                block, _, _ = nodeblock.rpartition(cls.seperator)
                raise KeyError(f"{node} already exists in {nodeblock}")
            tree[node] = cls.new_node()
            return tree[node]
        #
        branch_name, node_name = conditions
        branching = tree.get(branch_name, None)
        # insert new branching into tree
        tree[branch_name], node = cls._new_branching_node(branching, branch_name, node_name)
        return node

    @classmethod
    def _new_branching_node(cls, branching, branch_name, node_name):
        """
        Create a new node in a decissional branching, if the branching does not exist create it!

        Args:
            branching (obj):
                can be None, leaf node, branching

                    None: selected branching does not exist.
                          Create branching and a node
                          with name `node_name` inside the branching

               Leaf Node: selected branching does not exist, but a leaf node at that position
                          Create branching from that leaf node and init a node
                          with name `node_name` inside that branching

               Branching: selected branching does exist, and
                          an empty node will be created in that branching

        """
        if branching is None:
            branching = cls.new_branching(branch_name)
        elif isinstance(branching, cls.leafnode_type):
            branching = cls.new_branching(branch_name, leaf=branching)
        elif isinstance(branching, cls.branching_type):
            pass
        else:
            raise TypeError("Branching can only be typ: ",
                            f"'None', '{cls.leafnode_type}', '{cls.branching_type}'")
        #
        if node_name not in branching:
            branching[node_name] = cls.new_node()
        return branching, branching[node_name]

    @classmethod
    def _is_subblock(cls, block):
        """Check if block is further than one node away from
           the tree root """
        if any(key in block for key in (cls.seperator, '(', ')')):
            return True
        return False

    @classmethod
    def generate_tree(cls, config):
        """Generate a new tree from a configparser object

        Args:
            config (dict):
                linear dictionary of the corresponding config

        Returns:
            tree (object):
                parsed tree from the config file


        """
        # linear parser
        tree = cls.new_node()
        # parse defaults
        for key, value in config[cls.default].items():
            tree[key] = cls.leaf_from_string(key, value)
        # get subsections
        subsections = [section for section in config.sections() if cls._is_subblock(section)]
        # parse main sections
        for section in config.sections():
            if section == cls.default:
                continue
            if cls._is_subblock(section):
                continue
            subnode = cls.new_node()
            for key, value in config[section].items():
                subnode[key] = cls.leaf_from_string(key, value)
            tree[section] = subnode
        # parse all subsections
        for section in subsections:
            # gets the subnode, if it is a branching
            # and does not exist, creates it
            subnode = cls._select_subnode(tree, section)
            if subnode is None:
                continue
            for key, value in config[section].items():
                subnode[key] = cls.leaf_from_string(key, value)
        #
        return tree


class BranchingNode(MutableMapping):

    def __init__(self, name, leaf, subnodes={}):
        self.name = name
        self.leaf = leaf
        self.subnodes = subnodes 

    def __getitem__(self, key):
        return self.subnodes[key]

    def __setitem__(self, key, value):
        self.subnodes[key] = value

    def __delitem__(self, key):
        del self.subnodes[key]

    def __iter__(self):
        return iter(self.subnodes)

    def __len__(self):
        return len(self.subnodes)

    def __str__(self):
        return (f"BranchingNode(name = {self.name},"
                f" leaf = {self.leaf}, subnodes = {self.subnodes}")

    def __repr__(self):
        return (f"BranchingNode(name = {self.name},"
                f" leaf = {self.leaf}, subnodes = {self.subnodes}")
